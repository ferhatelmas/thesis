\chapter{Validation of PostgreSQL Decision}

Porting Room Booking module to PostgreSQL via SQLAlchemy has proved that PostgreSQL is a good solution for the problems of Indico.

\section{Comparison of PostgreSQL to Document-Oriented Databases in terms of Room Booking Module}

As seen in schema of Room Booking \ref{schema}, it's a tree from left to right, locations to reservations. Document-oriented databases are tailored this kind of data. If whole schema was composed of only room booking schema, then choosing a document-oriented database would be a better fit since only one entity is modified at a time and a document-oriented database such as MongoDB or CouchDB provides ACID-like guarantees in the document level.

In PostgreSQL, schema is fully normalized and accessing objects on the right such as repetitions of reservations usually requires joining of locations and rooms, and even occasionally joins combine blockings and a date generator. For example, booking search interface \ref{search} executes a left outer join with requested date range (generated by PostgreSQL), locations, rooms, reservations, reservation occurrences (materialized reservation recurrences) and blockings. Tuples are aggregated by date, room. and put into PostgreSQL arrays.

\begin{figure}[!ht]
  \caption{Booking Search Interface}
  \centering
    \includegraphics[scale=0.53]{7/figures/search.png}
  \label{search}
\end{figure}

Even if access flow gets more involving, writing queries with SQLAlchemy seemed to be comfortable because SQLAlchemy provides high level constructs such as directly mapping joins to lazy loaded collections in Python objects but it also enables literal SQL if needed. Thus, SQLAlchemy is in the both end of abstraction, it can be high and very low level at the same time according to needs.

Joins are the worst point of relational world. Main feature provided by room booking is searching for availability and then choosing a room. This feature roughly requires join of whole database. In ZODB, this big join was being done in client after inefficiently loading many unnecessary objects and generating repetitions. With B-Tree indexes on materialized reservation repetitions, PostgreSQL performs it instantly.

\section{Database Size}

Firstly, there was a packing need in ZODB to remove old versions of objects. With transition to PostgreSQL, this problem is solved for free.

Secondly, our biggest table in room booking is reservation repetitions with nearly half million rows which weren't put into database before. Even if they are materialized and room photos are put into database instead of being served from file system, database size is dramatically reduced compared to ZODB. It's around $\sim$400 MB and, now $\sim$130 MB, even $\sim$60 MB without occurrence and photo table. Thus, it is expected that main storage will occupy $\sim$3 gigabytes after complete transition which around $\sim$40 GB unpacked ($\sim$15GB packed), now because room booking showed PostgreSQL saved \%560 of space.

\begin{table}[t]
	\centering
    \begin{tabular}{ | c | c |}
    \hline
    \textbf{Table} & \textbf{Size} \\ \hline
	 pg\_toast & 37 MB \\ \hline
     reservations & 28 MB \\ \hline
     reservation\_occurrences & 27 MB \\ \hline
     reservation\_edit\_logs & 14 MB \\ \hline
     reservation\_occurrences\_pkey & 14 MB \\ \hline
     reservation\_edit\_logs\_pkey & 4736 kB \\ \hline
     reservations\_pkey & 3808 kB \\ \hline
     pg\_toast\_index & 432 kB \\ \hline
     pg\_toast & 336 kB \\ \hline
     pg\_toast & 136 kB \\ \hline
     rooms\_attributes\_association & 72 kB \\ \hline
     rooms\_attributes\_association\_pkey & 64 kB \\ \hline
     rooms & 56 kB \\ \hline
     rooms\_equipments\_pkey & 40 kB \\ \hline
     rooms\_equipments & 24 kB \\ \hline
     room\_equipments\_name\_location\_id\_key & 16 kB \\ \hline
     ix\_locations\_name & 16 kB \\ \hline
     ix\_start & 16 kB \\ \hline
     ix\_end & 16 kB \\ \hline
     locations\_pkey & 16 kB \\ \hline
     pg\_toast\_index & 16 kB \\ \hline
     room\_equipments\_pkey & 16 kB \\ \hline
    \end{tabular} 
    \caption{Size of Room Booking Module in PostgreSQL (first 20 large tables)}
    \label{limitations}
\end{table}

Exact size information can be seen in the table \ref{limitations}. Some rows which don't exist in schema, \textit{pg\_toast} rows, are written in PostgreSQL output. PostgreSQL has a fixed page size, generally $\sim$8 kilobytes which uses to load or flush records in batch. Moreover, PostgreSQL doesn't permit large records to span multiple pages because it introduces complexity and inefficiency such that modification requires twice of time. PostgreSQL transparently divides these big rows to multiple small physical rows and it's called TOAST\footnote{\url{http://www.postgresql.org/docs/9.3/static/storage-toast.html}} which also supports simple and fast compression. Therefore, our photos is a nice use-case for TOAST storage and as seen in table, the first \textit{pg\_toast} is our photo table.

\section{Documentation and Tooling}

One of our main differentiating factors in choosing new database was community and room booking porting experiment has confirmed that PostgreSQL and SQLAlchemy have really good documentation and vibrant community. ZODB barely has had documentation and some technical articles are occasionally published but that's all. However, getting questions answered instantly isn't literally false with many contributors on respective IRC channels, dedicated Stackoverflow\footnote{http://stackoverflow.com/} users and active online developers using these tools.

\section{Summary}

Expected features of PostgreSQL are validated and seamlessly and efficiently works. ZODB implementation is mirrored to PostgreSQL but PostgreSQL enables features which were impossible in ZODB due to loading strategy. 

For example, in ZODB, rooms can be loaded in different ways such that:
\begin{itemize}
  \item Only one room at a time
  \item Subset of rooms if they are put into a specific collection, such as all rooms
\end{itemize}

Since only collections can be retrieved in one connection, would-be-needed rooms should be put into a collection in advance. When multiple different subsets are needed, many different collections must be arranged in the database to be able to retrieve all of them in one access. Therefore, easiest way is to load everything and them to the client but this is costly. To overcome this problem, infinite scrolling may be implemented. Implementing infinite scrolling in ZODB was very difficult but PostgreSQL now makes it straightforward which may be leveraged by many pages of Indico such as reservation availability listing and hierarchy of categories.